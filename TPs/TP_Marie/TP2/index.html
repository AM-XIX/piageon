<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Mandelbrot 2D - Three.js</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #000;
        }

        #container {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .ui {
            position: fixed;
            left: 10px;
            top: 10px;
            color: #fff;
            font-family: system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
            background: rgba(0, 0, 0, 0.35);
            padding: 8px 10px;
            border-radius: 8px;
            backdrop-filter: blur(4px);
        }

        .ui small {
            display: block;
            opacity: 0.8
        }

        a {
            color: #9cf
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <div class="ui">
        <strong>Mandelbrot (Three.js)</strong>
        <small>Molette: zoom · Glisser: pan · Double-clic: reset</small>
    </div>

    <!-- Three.js (non-module build) -->
    <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>

    <script>
        //js embarqué
        (function () {
            const container = document.getElementById('container');

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Scene + camera 
            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            // Plane geometry that covers the screen
            const geometry = new THREE.PlaneGeometry(2, 2);

            // Shader
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    u_resolution: { value: new THREE.Vector2(container.clientWidth, container.clientHeight) },
                    u_zoom: { value: 3.0 },
                    u_offset: { value: new THREE.Vector2(-0.5, 0.0) },
                    u_iterations: { value: 200 },
                    u_time: { value: 0.0 },
                    u_aspect: { value: container.clientWidth / container.clientHeight }
                },
                vertexShader: `
        varying vec2 v_uv;
        void main(){
          v_uv = uv;
          gl_Position = vec4(position, 1.0);
        }
      `,
                fragmentShader: `
        precision highp float;
        varying vec2 v_uv;
        uniform vec2 u_resolution;
        uniform float u_zoom;
        uniform vec2 u_offset;
        uniform float u_time;
        uniform float u_iterations;
        uniform float u_aspect;

        vec3 palette(float t) {
  // Définition des couleurs (gradient)
  vec3 c1 = vec3(0.0, 0.2, 0.8);  // bleu
  vec3 c2 = vec3(0.4, 0.0, 0.6);  // violet
  vec3 c3 = vec3(0.9, 0.2, 0.7);  // rose
  vec3 c4 = vec3(1.0, 0.9, 0.4);  // jaune
  
  // Interpolation entre les couleurs
  if (t < 0.33) {
    return mix(c1, c2, smoothstep(0.0, 0.33, t));
  } else if (t < 0.66) {
    return mix(c2, c3, smoothstep(0.33, 0.66, t));
  } else {
    return mix(c3, c4, smoothstep(0.66, 1.0, t));
  }
}


        void main(){

          vec2 uv = v_uv - 0.5;
          uv.x *= u_aspect; 

          vec2 c = uv * u_zoom + u_offset;

          vec2 z = vec2(0.0);
          float iter = 0.0;
          float maxIter = u_iterations;
          float escapeRadius = 4.0;

          // Iterate
          for(float i=0.0; i<1000.0; i++){ 
            if(i >= maxIter) break;
            // z = z^2 + c
            float x = (z.x*z.x - z.y*z.y) + c.x;
            float y = (2.0*z.x*z.y) + c.y;
            z = vec2(x,y);

            if(dot(z,z) > escapeRadius) {
              iter = i;
              // smooth iteration count
              float log_zn = log(dot(z,z)) / 2.0;
              float nu = log(log_zn / log(2.0)) / log(2.0);
              iter = i + 1.0 - nu;
              break;
            }
          }

          if(iter == 0.0) {
            // inside black
            gl_FragColor = vec4(0.0,0.0,0.0,1.0);
          } else {
            float t = iter / maxIter;
            vec3 col = palette(t);
            gl_FragColor = vec4(col, 1.0);
          }
        }
      `
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Resize
            function onResize() {
                const w = container.clientWidth;
                const h = container.clientHeight;
                renderer.setSize(w, h);
                material.uniforms.u_resolution.value.set(w, h);
                material.uniforms.u_aspect.value = w / h;
                renderer.setPixelRatio(window.devicePixelRatio || 1);
            }
            window.addEventListener('resize', onResize, { passive: true });

            // Interaction: pan + zoom
            let isPointerDown = false;
            let lastX = 0, lastY = 0;

            container.addEventListener('pointerdown', (e) => {
                isPointerDown = true;
                lastX = e.clientX;
                lastY = e.clientY;
                container.setPointerCapture(e.pointerId);
            });
            container.addEventListener('pointerup', (e) => {
                isPointerDown = false;
                container.releasePointerCapture(e.pointerId);
            });
            container.addEventListener('pointermove', (e) => {
                if (!isPointerDown) return;
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                lastX = e.clientX; lastY = e.clientY;


                const w = container.clientWidth;
                const h = container.clientHeight;
                const aspect = w / h;
                const zoom = material.uniforms.u_zoom.value;

                const moveX = -dx / w * zoom * aspect;
                const moveY = dy / h * zoom;

                material.uniforms.u_offset.value.x += moveX;
                material.uniforms.u_offset.value.y += moveY;
            });

            // Wheel zoom
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = renderer.domElement.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const ndcX = (mx / rect.width) - 0.5;
                const ndcY = (my / rect.height) - 0.5;

                const aspect = material.uniforms.u_aspect.value;
                const zoom = material.uniforms.u_zoom.value;

                const cx = ndcX * zoom * aspect + material.uniforms.u_offset.value.x;
                const cy = ndcY * zoom + material.uniforms.u_offset.value.y;

                // Zoom factor
                const delta = Math.sign(e.deltaY) * 0.12;
                const factor = Math.exp(delta);
                let newZoom = zoom * factor;
                newZoom = Math.max(1e-10, Math.min(4e3, newZoom));
                material.uniforms.u_zoom.value = newZoom;

                material.uniforms.u_offset.value.x = cx - ndcX * newZoom * aspect;
                material.uniforms.u_offset.value.y = cy - ndcY * newZoom;
            }, { passive: false });

            // Double click to reset
            container.addEventListener('dblclick', () => {
                material.uniforms.u_zoom.value = 3.0;
                material.uniforms.u_offset.value.set(-0.5, 0.0);
                material.uniforms.u_iterations.value = 200.0;
            });

            // Animation
            const clock = new THREE.Clock();
            function animate() {
                material.uniforms.u_time.value = clock.getElapsedTime();
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
            animate();

            // Initial resize
            onResize();

            // Adapt iterations based on zoom for better detail
            (function adaptIterations() {
                const base = 200;
                function update() {
                    const z = material.uniforms.u_zoom.value;
                    // heuristics: more zoom -> more iterations
                    const it = Math.min(2000, Math.floor(base + Math.log2(Math.max(1, 3.0 / z)) * 80));
                    material.uniforms.u_iterations.value = it;
                    requestAnimationFrame(update);
                }
                update();
            })();

        })();
    </script>
</body>

</html>