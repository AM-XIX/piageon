<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Boids - Three.js</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #0b1020;
            overflow: hidden;
        }

        #container {
            width: 100%;
            height: 100%;
            position: relative
        }

        .ui {
            position: fixed;
            left: 12px;
            top: 12px;
            background: rgba(0, 0, 0, 0.35);
            color: #fff;
            padding: 10px;
            border-radius: 10px;
            font-family: system-ui, Segoe UI, Roboto, Arial;
            backdrop-filter: blur(6px);
        }

        .ui label {
            display: block;
            font-size: 13px;
            margin-top: 8px
        }

        .ui input[type=range] {
            width: 200px
        }

        .credits {
            position: fixed;
            right: 12px;
            bottom: 12px;
            color: #bbb;
            font-size: 13px
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <div class="ui">
        <strong>Boids (Three.js)</strong>
        <label>Boids: <span id="countLabel">300</span></label>
        <input id="count" type="range" min="50" max="1500" value="300">
        <label>Separation <span id="sepVal">1.5</span></label>
        <input id="sep" type="range" min="0" max="3" step="0.05" value="1.5">
        <label>Alignment <span id="aliVal">1.0</span></label>
        <input id="ali" type="range" min="0" max="3" step="0.05" value="1.0">
        <label>Cohesion <span id="cohVal">1.0</span></label>
        <input id="coh" type="range" min="0" max="3" step="0.05" value="1.0">
        <label>Perception <span id="perVal">60</span>px</label>
        <input id="per" type="range" min="10" max="200" value="60">
        <label>Max Speed <span id="spdVal">2.0</span></label>
        <input id="spd" type="range" min="0.1" max="10" step="0.1" value="2.0">
        <div style="margin-top:8px; font-size:12px; opacity:0.9">Molette: zoom · Glisser: orbite caméra · Clic: attirer
        </div>
    </div>
    <div class="credits">GPU-friendly points • simple neighbor search</div>

    <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
    <script>
        (function () {
            const container = document.getElementById('container');
            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Scene + camera
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 400);

            // Controls (simple orbit via pointer)
            let isPointerDown = false; let lastX = 0, lastY = 0; let theta = 0, phi = 0, dist = 400;
            renderer.domElement.addEventListener('pointerdown', (e) => { isPointerDown = true; lastX = e.clientX; lastY = e.clientY; renderer.domElement.setPointerCapture(e.pointerId); });
            renderer.domElement.addEventListener('pointerup', (e) => { isPointerDown = false; renderer.domElement.releasePointerCapture(e.pointerId); });
            renderer.domElement.addEventListener('pointermove', (e) => { if (!isPointerDown) return; const dx = (e.clientX - lastX); const dy = (e.clientY - lastY); lastX = e.clientX; lastY = e.clientY; theta += dx * 0.005; phi = Math.min(Math.max(phi + dy * 0.005, -Math.PI / 2 + 0.1), Math.PI / 2 - 0.1); updateCamera(); });
            renderer.domElement.addEventListener('wheel', (e) => { e.preventDefault(); dist *= Math.exp(e.deltaY * 0.0012); dist = Math.min(Math.max(dist, 50), 1200); updateCamera(); }, { passive: false });
            function updateCamera() { const x = dist * Math.cos(phi) * Math.sin(theta); const y = dist * Math.sin(phi); const z = dist * Math.cos(phi) * Math.cos(theta); camera.position.set(x, y, z); camera.lookAt(0, 0, 0); }

            // Boids parameters and UI
            const params = { count: 300, separation: 1.5, alignment: 1.0, cohesion: 1.0, perception: 60, maxSpeed: 2.0 };
            const ui = {
                count: document.getElementById('count'), countLabel: document.getElementById('countLabel'),
                sep: document.getElementById('sep'), sepVal: document.getElementById('sepVal'),
                ali: document.getElementById('ali'), aliVal: document.getElementById('aliVal'),
                coh: document.getElementById('coh'), cohVal: document.getElementById('cohVal'),
                per: document.getElementById('per'), perVal: document.getElementById('perVal'),
                spd: document.getElementById('spd'), spdVal: document.getElementById('spdVal')
            };

            function bindUI() {
                ui.count.addEventListener('input', () => { params.count = parseInt(ui.count.value); ui.countLabel.textContent = params.count; resetBoids(); });
                ui.sep.addEventListener('input', () => { params.separation = parseFloat(ui.sep.value); ui.sepVal.textContent = params.separation; });
                ui.ali.addEventListener('input', () => { params.alignment = parseFloat(ui.ali.value); ui.aliVal.textContent = params.alignment; });
                ui.coh.addEventListener('input', () => { params.cohesion = parseFloat(ui.coh.value); ui.cohVal.textContent = params.cohesion; });
                ui.per.addEventListener('input', () => { params.perception = parseFloat(ui.per.value); ui.perVal.textContent = params.perception; });
                ui.spd.addEventListener('input', () => { params.maxSpeed = parseFloat(ui.spd.value); ui.spdVal.textContent = params.maxSpeed; });
            }
            bindUI();

            // Boids data (typed arrays)
            let positions, velocities, accelerations, count;
            let points, geometry, material, positionsAttr;

            function initBoids(n) {
                count = n;
                positions = new Float32Array(count * 3);
                velocities = new Float32Array(count * 3);
                accelerations = new Float32Array(count * 3);
                // initialize random positions within a box
                for (let i = 0; i < count; i++) {
                    positions[i * 3 + 0] = (Math.random() - 0.5) * 600;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 400;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 600;
                    velocities[i * 3 + 0] = (Math.random() - 0.5) * 2;
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 2;
                    velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
                    accelerations[i * 3 + 0] = 0; accelerations[i * 3 + 1] = 0; accelerations[i * 3 + 2] = 0;
                }

                if (geometry) geometry.dispose();
                geometry = new THREE.BufferGeometry();
                positionsAttr = new THREE.BufferAttribute(positions, 3);
                geometry.setAttribute('position', positionsAttr);

                // Shader material for round points with gradient color based on speed
                material = new THREE.ShaderMaterial({
                    transparent: true,
                    depthTest: true,
                    uniforms: {
                        u_pointSize: { value: 6.0 },
                        u_cameraDistance: { value: dist }
                    },
                    vertexShader: `varying float v_speed;
uniform float u_pointSize;

void main() {
  v_speed = length(position); // position est déjà fournie
  vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
  gl_PointSize = u_pointSize * (300.0 / -mvPos.z);
  gl_Position = projectionMatrix * mvPos;
}`,
                    fragmentShader: `precision mediump float; varying float v_speed; void main(){ float r = length(gl_PointCoord - vec2(0.5)); if(r > 0.5) discard; // circular point
          // color ramp: bluish -> violet -> pink -> yellow based on v_speed (screen-space hack)
          float t = clamp(v_speed / 1200.0, 0.0, 1.0);
          vec3 c1 = vec3(0.0, 0.45, 0.9);
          vec3 c2 = vec3(0.5, 0.05, 0.7);
          vec3 c3 = vec3(0.95, 0.2, 0.7);
          vec3 c4 = vec3(1.0, 0.9, 0.4);
          vec3 col;
          if(t < 0.33) col = mix(c1, c2, smoothstep(0.0,0.33,t));
          else if(t < 0.66) col = mix(c2, c3, smoothstep(0.33,0.66,t));
          else col = mix(c3, c4, smoothstep(0.66,1.0,t));
          gl_FragColor = vec4(col, 1.0 - r*2.0);
        }`
                });

                if (points) scene.remove(points);
                points = new THREE.Points(geometry, material);
                scene.add(points);
            }

            function resetBoids() {
                initBoids(params.count);
            }

            // Simple neighbor search (O(N^2)). For larger counts, replace with spatial partitioning.
            function stepBoids(dt) {
                const per = params.perception;
                const per2 = per * per;
                for (let i = 0; i < count; i++) {
                    let ix = i * 3;
                    let px = positions[ix], py = positions[ix + 1], pz = positions[ix + 2];
                    let vx = velocities[ix], vy = velocities[ix + 1], vz = velocities[ix + 2];

                    // accumulators
                    let steerSx = 0, steerSy = 0, steerSz = 0, steerAx = 0, steerAy = 0, steerAz = 0, steerCx = 0, steerCy = 0, steerCz = 0;
                    let sepCount = 0, aliCount = 0, cohCount = 0;

                    for (let j = 0; j < count; j++) {
                        if (j === i) continue;
                        let jx = j * 3;
                        let qx = positions[jx], qy = positions[jx + 1], qz = positions[jx + 2];
                        let dx = qx - px; let dy = qy - py; let dz = qz - pz;
                        let d2 = dx * dx + dy * dy + dz * dz;
                        if (d2 < per2) {
                            let d = Math.sqrt(d2) + 1e-6;
                            // Separation (avoid crowding)
                            if (d < 1e-6) continue;
                            if (d < per) {
                                // vector pointing away weighted by distance
                                steerSx += (px - qx) / d; steerSy += (py - qy) / d; steerSz += (pz - qz) / d; sepCount++;
                                // Alignment
                                steerAx += velocities[jx]; steerAy += velocities[jx + 1]; steerAz += velocities[jx + 2]; aliCount++;
                                // Cohesion
                                steerCx += qx; steerCy += qy; steerCz += qz; cohCount++;
                            }
                        }
                    }

                    // compute final acceleration
                    let ax = 0, ay = 0, az = 0;
                    if (sepCount > 0) { ax += (steerSx / sepCount) * params.separation * 0.6; ay += (steerSy / sepCount) * params.separation * 0.6; az += (steerSz / sepCount) * params.separation * 0.6; }
                    if (aliCount > 0) { ax += ((steerAx / aliCount) - vx) * params.alignment * 0.05; ay += ((steerAy / aliCount) - vy) * params.alignment * 0.05; az += ((steerAz / aliCount) - vz) * params.alignment * 0.05; }
                    if (cohCount > 0) { ax += ((steerCx / cohCount) - px) * params.cohesion * 0.0008; ay += ((steerCy / cohCount) - py) * params.cohesion * 0.0008; az += ((steerCz / cohCount) - pz) * params.cohesion * 0.0008; }

                    // boundary - simple wrap
                    const B = 500;
                    if (px > B) px = -B; else if (px < -B) px = B;
                    if (py > B) py = -B; else if (py < -B) py = B;
                    if (pz > B) pz = -B; else if (pz < -B) pz = B;

                    // integrate
                    vx += ax * dt; vy += ay * dt; vz += az * dt;
                    // limit speed
                    const speed = Math.sqrt(vx * vx + vy * vy + vz * vz);
                    const maxS = params.maxSpeed;
                    if (speed > maxS) { const f = maxS / speed; vx *= f; vy *= f; vz *= f; }

                    positions[ix] = px + vx * dt * 60.0; // scale by 60 for nicer motion
                    positions[ix + 1] = py + vy * dt * 60.0;
                    positions[ix + 2] = pz + vz * dt * 60.0;

                    velocities[ix] = vx; velocities[ix + 1] = vy; velocities[ix + 2] = vz;
                }

                // update GPU geometry attribute
                positionsAttr.needsUpdate = true;
                geometry.computeBoundingSphere();
            }

            // Mouse attraction: hold click to attract boids to mouse world point
            let attractPoint = null; let attracting = false;
            renderer.domElement.addEventListener('pointerdown', (e) => { if (e.button === 0) { attracting = true; updateAttract(e); } });
            renderer.domElement.addEventListener('pointerup', (e) => { if (e.button === 0) { attracting = false; attractPoint = null; } });
            renderer.domElement.addEventListener('pointermove', (e) => { if (attracting) updateAttract(e); });
            function updateAttract(e) { const rect = renderer.domElement.getBoundingClientRect(); const mx = (e.clientX - rect.left) / rect.width * 2 - 1; const my = -((e.clientY - rect.top) / rect.height * 2 - 1); const v = new THREE.Vector3(mx, my, 0.5).unproject(camera); attractPoint = v; }

            // init
            initBoids(params.count);
            updateCamera();

            // animation loop
            let last = performance.now();
            function animate() {
                const now = performance.now();
                let dt = (now - last) / 1000; last = now; dt = Math.min(dt, 0.05);

                // if attracting, nudge velocities
                if (attractPoint) { for (let i = 0; i < count; i++) { const ix = i * 3; const px = positions[ix], py = positions[ix + 1], pz = positions[ix + 2]; const dx = attractPoint.x - px; const dy = attractPoint.y - py; const dz = attractPoint.z - pz; velocities[ix] += dx * 0.0005; velocities[ix + 1] += dy * 0.0005; velocities[ix + 2] += dz * 0.0005; } }

                stepBoids(dt);
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
            animate();

            window.addEventListener('resize', () => { renderer.setSize(container.clientWidth, container.clientHeight); camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix(); });

        })();
    </script>
</body>

</html>